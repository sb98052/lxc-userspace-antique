#!/usr/bin/python

import sys
import os
import setns

from argparse import ArgumentParser

drop_capabilities='cap_sys_admin,cap_sys_boot,cap_sys_module'

# can set to True here, but also use the -d option
debug = False

#################### should go into a separate libvirtsystemd.py
# but we want to keep packaging simple for now

# reproducing libvirt's systemd-oriented escaping mechanism
# http://code.metager.de/source/xref/lib/virt/src/util/virsystemd.c
# (see original code at the end of this file)

def virSystemdEscapeName (name):
    result=''
    def ESCAPE(c,s):
        # replace hex's output '0x..' into '\x..' 
        return s+hex(ord(c)).replace('0','\\',1)
    VALID_CHARS = \
        "0123456789" + \
        "abcdefghijklmnopqrstuvwxyz" + \
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + \
        ":-_.\\"
    for c in name:
        if c=='/': 
            result += '-'
        elif c in '-\\' or c not in VALID_CHARS:
            result=ESCAPE(c,result)
        else:
            result += c
    return result

#35static void virSystemdEscapeName(virBufferPtr buf,
#36                                 const char *name)
#37{
#38    static const char hextable[16] = "0123456789abcdef";
#39
#40#define ESCAPE(c)                                                       \
#41    do {                                                                \
#42        virBufferAddChar(buf, '\\');                                    \
#43        virBufferAddChar(buf, 'x');                                     \
#44        virBufferAddChar(buf, hextable[(c >> 4) & 15]);                 \
#45        virBufferAddChar(buf, hextable[c & 15]);                        \
#46    } while (0)
#47
#48#define VALID_CHARS                             \
#49        "0123456789"                            \
#50        "abcdefghijklmnopqrstuvwxyz"            \
#51        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"            \
#52        ":-_.\\"
#53
#54    if (*name == '.') {
#55        ESCAPE(*name);
#56        name++;
#57    }
#58
#59    while (*name) {
#60        if (*name == '/')
#61            virBufferAddChar(buf, '-');
#62        else if (*name == '-' ||
#63                 *name == '\\' ||
#64                 !strchr(VALID_CHARS, *name))
#65            ESCAPE(*name);
#66        else
#67            virBufferAddChar(buf, *name);
#68        name++;
#69    }
#70
#71#undef ESCAPE
#72#undef VALID_CHARS
#73}

def virSystemdMakeScopeName (name, drivername, partition):
    result=''
    result += virSystemdEscapeName (partition)
    result += '-'
    result += virSystemdEscapeName (drivername)
    result += '\\x2d'
    result += virSystemdEscapeName (name)
    result += '.scope'
    return result

#76char *virSystemdMakeScopeName(const char *name,
#77                              const char *drivername,
#78                              const char *partition)
#79{
#80    virBuffer buf = VIR_BUFFER_INITIALIZER;
#81
#82    if (*partition == '/')
#83        partition++;
#84
#85    virSystemdEscapeName(&buf, partition);
#86    virBufferAddChar(&buf, '-');
#87    virSystemdEscapeName(&buf, drivername);
#88    virBufferAddLit(&buf, "\\x2d");
#89    virSystemdEscapeName(&buf, name);
#90    virBufferAddLit(&buf, ".scope");
#91
#92    if (virBufferError(&buf)) {
#93        virReportOOMError();
#94        return NULL;
#95    }
#96
#97    return virBufferContentAndReset(&buf);
#98}

### our own additions
# heuristics to locate /sys/fs/cgroup stuff
import os.path
def find_first_dir (candidates):
    for candidate in candidates:
        if os.path.isdir(candidate): return candidate
    raise Exception,"Cannot find valid dir among\n" + "\n".join([" ->"+c for c in candidates])

def find_sysfs_scope (subsystem, slice_name):
    subsystem1=subsystem
    subsystem2=subsystem
    if subsystem=='cpuacct':
        subsystem2='cpu,cpuacct'
    candidates = [ 
        # for f16 and our locally brewed libvirt 1.0.4
        "/sys/fs/cgroup/%s/libvirt/lxc/%s"%(subsystem1, slice_name),
        "/sys/fs/cgroup/%s/system/libvirtd.service/libvirt/lxc/%s"%(subsystem1, slice_name),
        # f20 and libvirt 1.1.3
        "/sys/fs/cgroup/%s/machine.slice/%s"%(subsystem2, 
                                              virSystemdMakeScopeName(slice_name,'lxc','machine')),
        ]
    return find_first_dir (candidates)

#################### end of libvirtsystemd.py

def getarch(f):
    output = os.popen('readelf -h %s 2>&1'%f).readlines()
    classlines = [x for x in output if ('Class' in x.split(':')[0])]
    line = classlines[0]
    c = line.split(':')[1]
    if ('ELF64' in c):
        return 'x86_64'
    elif ('ELF32' in c):
        return 'i686'
    else:
        raise Exception('Could not determine architecture')

def umount(fs_dir, opts=''):
    output = os.popen('/bin/umount %s %s 2>&1'%(opts, fs_dir)).read()
    return ('device is busy' not in output)

def main ():
    parser = ArgumentParser()
    parser.add_argument("-n", "--nonet",
					action="store_true", dest="netns", default=False,
					help="Don't enter network namespace")
    parser.add_argument("-m", "--nomnt",
					action="store_true", dest="mntns", default=False,
					help="Don't enter mount namespace")
    parser.add_argument("-p", "--nopid",
					action="store_true", dest="pidns", default=False,
					help="Don't enter pid namespace")
    parser.add_argument("-r", "--root",
					action="store_true", dest="root", default=False,
					help="Enter as root: be careful")
    parser.add_argument("-i","--internal",
					action="store_true", dest="internal", default=False,
					help="does *not* prepend '-- -c' to arguments - or invoke lxcsu-internal")
    parser.add_argument("-d","--debug",
					action='store_true', dest='debug', default=False,
					help="debug option")
    parser.add_argument("-s","--nosliceuid",
					action='store_true', dest="nosliceuid", default=False,
					help="do not change to slice uid inside of slice")
    parser.add_argument("-o","--noslicehome",
					action='store_true', dest="noslicehome", default=False,
					help="do not change to slice home directory inside of slice")

    if os.path.exists("/etc/lxcsu_default"):
        defaults = parser.parse_args(file("/etc/lxcsu_default","r").read().split())
        parser.set_defaults(**defaults.__dict__)

    parser.add_argument ("slice_name")
    parser.add_argument ("command_to_run",nargs="*")

    args = parser.parse_args()
    slice_name=args.slice_name

    # unless we run the symlink 'lxcsu-internal', or we specify the -i option, prepend '--' '-c'
    if sys.argv[0].find('internal')>=0: args.internal=True

    if len(args.command_to_run)>0 and (args.command_to_run[0] == "/sbin/service"):
        # A quick hack to support nodemanager interfaces.py when restarting
        # networking in a slice.
        args.nosliceuid = True

    # plain lxcsu
    if not args.internal:
	# no command given: enter interactive shell
	if not args.command_to_run: args.command_to_run=['/bin/sh']
	args.command_to_run = [ '-c' ] + [" ".join(args.command_to_run)]

    # support for either setting debug at the top of this file, or on the command-line
    if args.debug:
        global debug
	debug=True

    try:
        cmd = '/usr/bin/virsh --connect lxc:/// domid %s'%slice_name
	pidnum = int(os.popen(cmd).read().rstrip())
    except:
        print "Domain %s not found"%slice_name
	exit(1)

    pid = '%s'%pidnum
    if debug: print "Found pidnum",pidnum
    cmdline = open('/proc/%s/cmdline'%pidnum).read().rstrip('\n\x00')
    arch = getarch('/proc/%s/exe'%pid)

    if (not pid):
        print "Domain %s not started"%slice_name
	exit(1)

    if arch is None:
	arch = 'x86_64'

    # Set sysctls specific to slice
    sysctls = []
    sysctl_dir = '/etc/planetlab/vsys-attributes/%s'%slice_name
    if (os.access(sysctl_dir,0)):
        entries = os.listdir(sysctl_dir)
	for e in entries:
            prefix = 'vsys_sysctl.'
	    if (e.startswith(prefix)):
		sysctl_file = '/'.join([sysctl_dir,e])
		sysctl_name = e[len(prefix):]
		sysctl_val = open(sysctl_file).read()
		sysctls.append((sysctl_file, sysctl_name, sysctl_val))

    # Enter cgroups
    # do not exit right away when something goes wrong
    # check as much as we can and only then exit
    cgroups_ok=True
    for subsystem in ['cpuset' ,'memory' ,'blkio', 'cpuacct']:
        try:
            open( find_sysfs_scope (subsystem, slice_name)+"/tasks", 'w').write(str(os.getpid()))
        except Exception,e:
            if debug: print e 
            print "ERROR assigning resources for %s in subsystem %s - bailing out"%(slice_name,subsystem)
            cgroups_ok=False

    # If the slice is frozen, then we'll get an EBUSY when trying to write to the task
    # list for the freezer cgroup. Since the user couldn't do anything anyway, it's best
    # in this case to error out the shell. (an alternative would be to un-freeze it,
    # add the task, and re-freeze it)
    try:
	f=open( find_sysfs_scope ('freezer', slice_name)+"/tasks", 'w')
	f.write(str(os.getpid()))
	# note: we need to call f.close() explicitly, or we'll get an exception in
	# the object destructor, which will not be caught
	f.close()
    except Exception,e:
	if debug: print e 
	print "Error adding task to freezer cgroup. Slice is probably frozen: %s" % slice_name
        cgroups_ok=False

    setns.chcontext('/proc/%s/ns/uts'%pid)
    setns.chcontext('/proc/%s/ns/ipc'%pid)
	
    if (not args.pidns):
	setns.chcontext('/proc/%s/ns/pid'%pid)

    if (not args.netns):
	setns.chcontext('/proc/%s/ns/net'%pid)

    if (not args.mntns):
	setns.chcontext('/proc/%s/ns/mnt'%pid)

    proc_mounted = False
    if (not os.access('/proc/self',0)):
	proc_mounted = True
	setns.proc_mount()

    for (sysctl_file, sysctl_name, sysctl_val) in sysctls:
	for fn in ["/sbin/sysctl", "/usr/sbin/sysctl", "/bin/sysctl", "/usr/bin/sysctl"]:
	    if os.path.exists(fn):
		os.system('%s -w %s=%s  >/dev/null 2>&1'%(fn, sysctl_name,sysctl_val))
		break
	    else:
		print "Error: image does not have a sysctl binary"

    # cgroups is not yet LXC-safe, so we need to use the coarse grained access control
    # strategy of unmounting the filesystem

    umount_result = True
    for subsystem in ['cpuset','cpu,cpuacct','memory','devices','freezer','net_cls','blkio','perf_event','systemd']:
	fs_path = '/sys/fs/cgroup/%s'%subsystem
	if (not umount(fs_path,'-l')):
	    pass
	    # Leaving these comments for historical reference
	    #print "Error disabling cgroup access"
	    #exit(1) - Don't need this because failure here implies failure in the call to umount /sys/fs/cgroup

    if (not umount('/sys/fs/cgroup')):
        print "Error disabling cgroup access"
        cgroups_ok=False

    if not cgroups_ok:
        print 'exiting'
        exit(1)

    pid = os.fork()

    # capsh has a --user option starting with f14
    # so if only for f12 we need to fake this one
    #
    # capsh.c does essentially the following when invoked with --user:
    #		pwd = getpwnam(user); ...
    #		ngroups = MAX_GROUPS; 
    #		status = getgrouplist(user, pwd->pw_gid, groups, &ngroups); ...
    #		status = setgroups(ngroups, groups); ...
    #		status = setgid(pwd->pw_gid); ...
    #		status = setuid(pwd->pw_uid); ...
    # however we cannot simulate that ourselves because if we did in this process then
    # capsh could not be allowed to mess with caps any more

    def getuid (slicename):
        import pwd
        try:
            return pwd.getpwnam(slicename).pw_uid
        except:
            return

    if (pid == 0):
        cap_arg = '--drop='+drop_capabilities

        if (not args.root):
            if (args.nosliceuid):
                # we still want to drop capabilities, but don't want to switch UIDs
                exec_args = [arch,'/usr/sbin/capsh',cap_arg,'--','--login',]+args.command_to_run
            else:
                uid = getuid (slice_name)
                if not uid:
                    print "lxcsu could not spot %s in /etc/passwd - exiting"%slice_name
                    exit(1)
                exec_args = [arch,'/usr/sbin/capsh',cap_arg,'--uid=%s'%uid,'--','--login',]+args.command_to_run
# once we can drop f12, it would be nicer to instead go for
# exec_args = [arch,'/usr/sbin/capsh',cap_arg,'--user=%s'%slice_name,'--','--login',]+args.command_to_run
        else:
            exec_args = [arch,'/usr/sbin/capsh','--','--login']+args.command_to_run

        os.environ['SHELL'] = '/bin/sh'
        if os.path.exists('/etc/planetlab/lib/bind_public.so'):
            os.environ['LD_PRELOAD'] = '/etc/planetlab/lib/bind_public.so'
        if not args.noslicehome:
            os.environ['HOME'] = '/home/%s'%slice_name
            os.chdir("/home/%s"%(slice_name))
        if debug: print 'lxcsu:execv:','/usr/bin/setarch',exec_args
        os.execv('/usr/bin/setarch',exec_args)
    else:
        setns.proc_umount()
        _,status = os.waitpid(pid,0)
        exit(os.WEXITSTATUS(status))

if __name__ == '__main__':
	main()
